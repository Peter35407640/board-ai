package io.github.pbanasiak.boardai.mcts

import io.github.pbanasiak.boardai.*
import io.github.pbanasiak.boardai.mcts.{MctsTreeNode, NodeCreator, NodeStatistics}
import io.github.pbanasiak.boardai.nn.{GameStateEncoder, PolicyValueModel}

import scala.annotation.tailrec
import scala.util.Random

case class MonteCarloNnPlayer[B, M, EncodedType](
  game: Game[B, M],
  nodeCreator: NodeCreator[B, M],
  encoder: GameStateEncoder[B, M, EncodedType],
  policyValueModel: PolicyValueModel[EncodedType],
  depthLimit: Int,
  ) extends McPlayer[B, M] {
  /**
   * Plays stochastically to the end of the game to determine a winner.
   * Moves use the probability distribution determined by the model priors instead of being completely random.
   * need MctsTreeNode not just GameState because of Stochastic sampling needs priors
   *
   * @param node current state to play from
   * @return the value from the point of view of the current player
   */
  override def valueFromMCPlayout(node: MctsTreeNode[GameState[B, M], M]):MctsTreeNode[GameState[B, M], M] =
    valueFromMCPlayout(node, depthLimit)

  /*
  Node contains priorScore: Score , its generated by NN model , and can be used in mctAgent
   */
  @tailrec
  private def valueFromMCPlayout(node: MctsTreeNode[GameState[B, M], M], depth: Int):MctsTreeNode[GameState[B, M], M] =
    if (node.gameState.isOver) {
      node
    } else {
      if (depth <= 0) {

        /*
         nodeCreator set priorScore using NN model
         */
        return node
      }
      val move = highestScoringMove(node)
      val newState = game.applyMove(node.gameState, move)
      // The parent is None because the playout does not need to be part of the MCTree.
      // move priors arr[] is calculated
      val childNode = nodeCreator.createNode(newState, Some(move), None)
      valueFromMCPlayout(childNode, depth - 1)
    }

  private def highestScoringMove(node: MctsTreeNode[GameState[B, M], M]): M = {
    if (node.branches.size == 1) {
      node.branches.keys.head
    } else {
      val movesWithPriors: List[(M, NodeStatistics)] = node.branches.toList
      movesWithPriors.maxBy(_._2.prior)._1
    }
  }
}
